import { Emitter } from "@socket.io/component-emitter";
import type { Packet, BinaryType, RawData } from "engine.io-parser";
import { CloseDetails, Transport } from "./transport.js";
<<<<<<< HEAD
import { CookieJar } from "./globals.node.js";
=======
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
export interface SocketOptions {
    /**
     * The host that we're connecting to. Set from the URI passed when connecting
     */
<<<<<<< HEAD
    host?: string;
    /**
     * The hostname for our connection. Set from the URI passed when connecting
     */
    hostname?: string;
    /**
     * If this is a secure connection. Set from the URI passed when connecting
     */
    secure?: boolean;
    /**
     * The port for our connection. Set from the URI passed when connecting
     */
    port?: string | number;
    /**
     * Any query parameters in our uri. Set from the URI passed when connecting
     */
    query?: {
=======
    host: string;
    /**
     * The hostname for our connection. Set from the URI passed when connecting
     */
    hostname: string;
    /**
     * If this is a secure connection. Set from the URI passed when connecting
     */
    secure: boolean;
    /**
     * The port for our connection. Set from the URI passed when connecting
     */
    port: string | number;
    /**
     * Any query parameters in our uri. Set from the URI passed when connecting
     */
    query: {
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
        [key: string]: any;
    };
    /**
     * `http.Agent` to use, defaults to `false` (NodeJS only)
     *
     * Note: the type should be "undefined | http.Agent | https.Agent | false", but this would break browser-only clients.
     *
     * @see https://nodejs.org/api/http.html#httprequestoptions-callback
     */
<<<<<<< HEAD
    agent?: string | boolean;
=======
    agent: string | boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Whether the client should try to upgrade the transport from
     * long-polling to something better.
     * @default true
     */
<<<<<<< HEAD
    upgrade?: boolean;
=======
    upgrade: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Forces base 64 encoding for polling transport even when XHR2
     * responseType is available and WebSocket even if the used standard
     * supports binary.
     */
<<<<<<< HEAD
    forceBase64?: boolean;
=======
    forceBase64: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * The param name to use as our timestamp key
     * @default 't'
     */
<<<<<<< HEAD
    timestampParam?: string;
=======
    timestampParam: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Whether to add the timestamp with each transport request. Note: this
     * is ignored if the browser is IE or Android, in which case requests
     * are always stamped
     * @default false
     */
<<<<<<< HEAD
    timestampRequests?: boolean;
=======
    timestampRequests: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * A list of transports to try (in order). Engine.io always attempts to
     * connect directly with the first one, provided the feature detection test
     * for it passes.
     *
     * @default ['polling','websocket', 'webtransport']
     */
<<<<<<< HEAD
    transports?: ("polling" | "websocket" | "webtransport" | string)[] | TransportCtor[];
    /**
     * Whether all the transports should be tested, instead of just the first one.
     *
     * If set to `true`, the client will first try to connect with HTTP long-polling, and then with WebSocket in case of
     * failure, and finally with WebTransport if the previous attempts have failed.
     *
     * If set to `false` (default), if the connection with HTTP long-polling fails, then the client will not test the
     * other transports and will abort the connection.
     *
     * @default false
     */
    tryAllTransports?: boolean;
=======
    transports: string[];
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * If true and if the previous websocket connection to the server succeeded,
     * the connection attempt will bypass the normal upgrade process and will
     * initially try websocket. A connection attempt following a transport error
     * will use the normal upgrade process. It is recommended you turn this on
     * only when using SSL/TLS connections, or if you know that your network does
     * not block websockets.
     * @default false
     */
<<<<<<< HEAD
    rememberUpgrade?: boolean;
    /**
     * Timeout for xhr-polling requests in milliseconds (0) (only for polling transport)
     */
    requestTimeout?: number;
    /**
     * Transport options for Node.js client (headers etc)
     */
    transportOptions?: Object;
=======
    rememberUpgrade: boolean;
    /**
     * Are we only interested in transports that support binary?
     */
    onlyBinaryUpgrades: boolean;
    /**
     * Timeout for xhr-polling requests in milliseconds (0) (only for polling transport)
     */
    requestTimeout: number;
    /**
     * Transport options for Node.js client (headers etc)
     */
    transportOptions: Object;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) Certificate, Private key and CA certificates to use for SSL.
     * Can be used in Node.js client environment to manually specify
     * certificate information.
     */
<<<<<<< HEAD
    pfx?: string;
=======
    pfx: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) Private key to use for SSL. Can be used in Node.js client
     * environment to manually specify certificate information.
     */
<<<<<<< HEAD
    key?: string;
=======
    key: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) A string or passphrase for the private key or pfx. Can be
     * used in Node.js client environment to manually specify certificate
     * information.
     */
<<<<<<< HEAD
    passphrase?: string;
=======
    passphrase: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) Public x509 certificate to use. Can be used in Node.js client
     * environment to manually specify certificate information.
     */
<<<<<<< HEAD
    cert?: string;
=======
    cert: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) An authority certificate or array of authority certificates to
     * check the remote host against.. Can be used in Node.js client
     * environment to manually specify certificate information.
     */
<<<<<<< HEAD
    ca?: string | string[];
=======
    ca: string | string[];
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) A string describing the ciphers to use or exclude. Consult the
     * [cipher format list]
     * (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) for
     * details on the format.. Can be used in Node.js client environment to
     * manually specify certificate information.
     */
<<<<<<< HEAD
    ciphers?: string;
=======
    ciphers: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * (SSL) If true, the server certificate is verified against the list of
     * supplied CAs. An 'error' event is emitted if verification fails.
     * Verification happens at the connection level, before the HTTP request
     * is sent. Can be used in Node.js client environment to manually specify
     * certificate information.
     */
<<<<<<< HEAD
    rejectUnauthorized?: boolean;
=======
    rejectUnauthorized: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Headers that will be passed for each request to the server (via xhr-polling and via websockets).
     * These values then can be used during handshake or for special proxies.
     */
    extraHeaders?: {
        [header: string]: string;
    };
    /**
     * Whether to include credentials (cookies, authorization headers, TLS
     * client certificates, etc.) with cross-origin XHR polling requests
     * @default false
     */
<<<<<<< HEAD
    withCredentials?: boolean;
=======
    withCredentials: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Whether to automatically close the connection whenever the beforeunload event is received.
     * @default false
     */
<<<<<<< HEAD
    closeOnBeforeunload?: boolean;
=======
    closeOnBeforeunload: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Whether to always use the native timeouts. This allows the client to
     * reconnect when the native timeout functions are overridden, such as when
     * mock clocks are installed.
     * @default false
     */
<<<<<<< HEAD
    useNativeTimers?: boolean;
    /**
     * Whether the heartbeat timer should be unref'ed, in order not to keep the Node.js event loop active.
     *
     * @see https://nodejs.org/api/timers.html#timeoutunref
     * @default false
     */
    autoUnref?: boolean;
=======
    useNativeTimers: boolean;
    /**
     * weather we should unref the reconnect timer when it is
     * create automatically
     * @default false
     */
    autoUnref: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable.
     * @default false
     */
<<<<<<< HEAD
    perMessageDeflate?: {
=======
    perMessageDeflate: {
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
        threshold: number;
    };
    /**
     * The path to get our client file from, in the case of the server
     * serving it
     * @default '/engine.io'
     */
<<<<<<< HEAD
    path?: string;
=======
    path: string;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Whether we should add a trailing slash to the request path.
     * @default true
     */
<<<<<<< HEAD
    addTrailingSlash?: boolean;
=======
    addTrailingSlash: boolean;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols,
     * so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to
     * be able to handle different types of interactions depending on the specified protocol)
     * @default []
     */
<<<<<<< HEAD
    protocols?: string | string[];
}
type TransportCtor = {
    new (o: any): Transport;
};
type BaseSocketOptions = Omit<SocketOptions, "transports"> & {
    transports: TransportCtor[];
};
=======
    protocols: string | string[];
}
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
interface HandshakeData {
    sid: string;
    upgrades: string[];
    pingInterval: number;
    pingTimeout: number;
    maxPayload: number;
}
interface SocketReservedEvents {
    open: () => void;
    handshake: (data: HandshakeData) => void;
    packet: (packet: Packet) => void;
    packetCreate: (packet: Packet) => void;
<<<<<<< HEAD
    data: (data: RawData) => void;
    message: (data: RawData) => void;
=======
    data: (data: any) => void;
    message: (data: any) => void;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    drain: () => void;
    flush: () => void;
    heartbeat: () => void;
    ping: () => void;
    pong: () => void;
    error: (err: string | Error) => void;
<<<<<<< HEAD
    upgrading: (transport: Transport) => void;
    upgrade: (transport: Transport) => void;
=======
    upgrading: (transport: any) => void;
    upgrade: (transport: any) => void;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    upgradeError: (err: Error) => void;
    close: (reason: string, description?: CloseDetails | Error) => void;
}
type SocketState = "opening" | "open" | "closing" | "closed";
<<<<<<< HEAD
interface WriteOptions {
    compress?: boolean;
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
export declare class SocketWithoutUpgrade extends Emitter<Record<never, never>, Record<never, never>, SocketReservedEvents> {
=======
export declare class Socket extends Emitter<Record<never, never>, Record<never, never>, SocketReservedEvents> {
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    id: string;
    transport: Transport;
    binaryType: BinaryType;
    readyState: SocketState;
    writeBuffer: Packet[];
<<<<<<< HEAD
    protected readonly opts: BaseSocketOptions;
    protected readonly transports: string[];
    protected upgrading: boolean;
    protected setTimeoutFn: typeof setTimeout;
    private _prevBufferLen;
    private _pingInterval;
    private _pingTimeout;
    private _maxPayload?;
    private _pingTimeoutTimer;
    /**
     * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
     * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
     */
    private _pingTimeoutTime;
    private clearTimeoutFn;
    private readonly _beforeunloadEventListener;
    private readonly _offlineEventListener;
    private readonly secure;
    private readonly hostname;
    private readonly port;
    private readonly _transportsByName;
    /**
     * The cookie jar will store the cookies sent by the server (Node. js only).
     */
    readonly _cookieJar: CookieJar;
=======
    private prevBufferLen;
    private upgrades;
    private pingInterval;
    private pingTimeout;
    private pingTimeoutTimer;
    private setTimeoutFn;
    private clearTimeoutFn;
    private readonly beforeunloadEventListener;
    private readonly offlineEventListener;
    private upgrading;
    private maxPayload?;
    private readonly opts;
    private readonly secure;
    private readonly hostname;
    private readonly port;
    private readonly transports;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    static priorWebsocketSuccess: boolean;
    static protocol: number;
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
<<<<<<< HEAD
    constructor(uri: string | BaseSocketOptions, opts: BaseSocketOptions);
=======
    constructor(uri: any, opts?: Partial<SocketOptions>);
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
<<<<<<< HEAD
    protected createTransport(name: string): Transport;
=======
    private createTransport;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
<<<<<<< HEAD
    private _open;
=======
    private open;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
<<<<<<< HEAD
    protected setTransport(transport: Transport): void;
=======
    private setTransport;
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    private probe;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
<<<<<<< HEAD
    protected onOpen(): void;
=======
    private onOpen;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Handles a packet.
     *
     * @private
     */
<<<<<<< HEAD
    private _onPacket;
=======
    private onPacket;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
<<<<<<< HEAD
    protected onHandshake(data: HandshakeData): void;
=======
    private onHandshake;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
<<<<<<< HEAD
    private _resetPingTimeout;
=======
    private resetPingTimeout;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Called on `drain` event
     *
     * @private
     */
<<<<<<< HEAD
    private _onDrain;
=======
    private onDrain;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Flush write buffers.
     *
     * @private
     */
<<<<<<< HEAD
    protected flush(): void;
=======
    private flush;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
<<<<<<< HEAD
    private _getWritablePackets;
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    _hasPingExpired(): boolean;
=======
    private getWritablePackets;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
<<<<<<< HEAD
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    write(msg: RawData, options?: WriteOptions, fn?: () => void): this;
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    send(msg: RawData, options?: WriteOptions, fn?: () => void): this;
=======
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg: RawData, options?: any, fn?: any): this;
    send(msg: RawData, options?: any, fn?: any): this;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
<<<<<<< HEAD
    private _sendPacket;
=======
    private sendPacket;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Closes the connection.
     */
    close(): this;
    /**
     * Called upon transport error
     *
     * @private
     */
<<<<<<< HEAD
    private _onError;
=======
    private onError;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Called upon transport close.
     *
     * @private
     */
<<<<<<< HEAD
    private _onClose;
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
export declare class SocketWithUpgrade extends SocketWithoutUpgrade {
    private _upgrades;
    onOpen(): void;
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    private _probe;
    onHandshake(data: HandshakeData): void;
=======
    private onClose;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
<<<<<<< HEAD
    private _filterUpgrades;
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
export declare class Socket extends SocketWithUpgrade {
    constructor(uri?: string, opts?: SocketOptions);
    constructor(opts: SocketOptions);
=======
    private filterUpgrades;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
}
export {};
