import { Transport } from "../transport.js";
<<<<<<< HEAD
import { nextTick } from "../globals.node.js";
import { createPacketDecoderStream, createPacketEncoderStream, } from "engine.io-parser";
import debugModule from "debug"; // debug()
const debug = debugModule("engine.io-client:webtransport"); // debug()
/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
=======
import { nextTick } from "./websocket-constructor.js";
import { createPacketDecoderStream, createPacketEncoderStream, } from "engine.io-parser";
import debugModule from "debug"; // debug()
const debug = debugModule("engine.io-client:webtransport"); // debug()
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
export class WT extends Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
<<<<<<< HEAD
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
=======
        // @ts-ignore
        if (typeof WebTransport !== "function") {
            return;
        }
        // @ts-ignore
        this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        this.transport.closed
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
            .then(() => {
            debug("transport closed gracefully");
            this.onClose();
        })
            .catch((err) => {
            debug("transport closed due to %s", err);
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
<<<<<<< HEAD
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
=======
        this.transport.ready.then(() => {
            this.transport.createBidirectionalStream().then((stream) => {
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = createPacketEncoderStream();
                encoderStream.readable.pipeTo(stream.writable);
<<<<<<< HEAD
                this._writer = encoderStream.writable.getWriter();
=======
                this.writer = encoderStream.writable.getWriter();
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            debug("session is closed");
                            return;
                        }
                        debug("received chunk: %o", value);
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                        debug("an error occurred while reading: %s", err);
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
<<<<<<< HEAD
                this._writer.write(packet).then(() => this.onOpen());
=======
                this.writer.write(packet).then(() => this.onOpen());
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
<<<<<<< HEAD
            this._writer.write(packet).then(() => {
=======
            this.writer.write(packet).then(() => {
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
                if (lastPacket) {
                    nextTick(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
<<<<<<< HEAD
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
=======
        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    }
}
