<<<<<<< HEAD
import type { ToJSContext } from '../../nodes/toJS';
import { YAMLMap } from '../../nodes/YAMLMap';
import { YAMLSeq } from '../../nodes/YAMLSeq';
import type { CreateNodeContext } from '../../util';
import type { Schema } from '../Schema';
import type { CollectionTag } from '../types';
export declare class YAMLOMap extends YAMLSeq {
    static tag: string;
    constructor();
    add: typeof YAMLMap.prototype.add;
    delete: typeof YAMLMap.prototype.delete;
    get: typeof YAMLMap.prototype.get;
    has: typeof YAMLMap.prototype.has;
    set: typeof YAMLMap.prototype.set;
=======
import { ToJSContext } from '../../nodes/toJS.js';
import { YAMLSeq } from '../../nodes/YAMLSeq.js';
import { CreateNodeContext } from '../../util.js';
import type { Schema } from '../Schema.js';
import { CollectionTag } from '../types.js';
export declare class YAMLOMap extends YAMLSeq {
    static tag: string;
    constructor();
    add: (pair: import("../../index.js").Pair<any, any> | {
        key: any;
        value: any;
    }, overwrite?: boolean) => void;
    delete: (key: unknown) => boolean;
    get: {
        (key: unknown, keepScalar: true): import("../../index.js").Scalar<any> | undefined;
        (key: unknown, keepScalar?: false): any;
        (key: unknown, keepScalar?: boolean): any;
    };
    has: (key: unknown) => boolean;
    set: (key: any, value: any) => void;
>>>>>>> 981e02d8b3161fb3284b6e7416793ef8f82f8915
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_?: unknown, ctx?: ToJSContext): unknown[];
    static from(schema: Schema, iterable: unknown, ctx: CreateNodeContext): YAMLOMap;
}
export declare const omap: CollectionTag;
